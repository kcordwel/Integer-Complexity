import sys
sys.path.insert(0,'/Volumes/RIEMANN/Todo/Matematicas/Python')
from A000792 import *
#from math import log
from math import ceil

#print [A000792(n) for n in range(1,21)]


from math import *
nMax = 2000000
pot_num_imp = 0


cMax = int(ceil(3.*log(nMax)/log(2)))
print 'cMax = ', cMax
# initialize the dictionary 
Compl={}
for n in range(2,nMax+1):
    Compl[n]=cMax
Compl[1]=1
# now Compl[n] is always greater or equal to the true complexity
for n in range(2,nMax+1):
    # test the sums
    a = Compl[n-1]+1
    if a < Compl[n]:
        Compl[n]=a  # the usual best value
    #print [Compl[i] for i in range(1,13)]
    target = Compl[n-1]
    #print 'target = ', target
    k=target/2
    #print 'k = ', k
    while (A000792(k)+A000792(target-k)<n):
        k=k-1
    limitm = A000792(k)
    opt_bound = float(3.3)/3 - 1
    up_to = int(ceil(n**opt_bound))
    if limitm > up_to:
        pot_num_imp = pot_num_imp + 1
#    print limitm
    #print 'For n = ',n, '  we find limitm = ', limitm, ' and k = ',k
    for m in range(6,limitm+1):
        sumvalue = Compl[m]+Compl[n-m]
        if sumvalue < Compl[n]:
            Compl[n] = sumvalue
            #print 'counterexample found for n = ', n
    # test for the products
    for k in range(2, min(n,nMax/n)+1):
        prodvalue = Compl[k]+Compl[n]
        if prodvalue <Compl[k*n]:
            Compl[k*n]=prodvalue
    # end of computation of complexities
print "Computed complexities upto nMax Compl[",nMax,"] = ", Compl[nMax]
print "Potential num improved is", pot_num_imp

"""
    # report the first value. For example
first =0
for n in range(1,nMax+1):
    if Compl[n]>first:
        first = Compl[n]
        print 'First value of complexity ', Compl[n], '  taken for n = ', n
"""
