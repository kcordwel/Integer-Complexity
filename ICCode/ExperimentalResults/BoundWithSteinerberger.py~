#from __future__ import division
import sys
sys.path.insert(0,'/Volumes/RIEMANN/Todo/Matematicas/Python')
from A000792 import *
from fractions import Fraction
from math import ceil
from math import log
from math import floor
from math import *

markov_dict = {}

def markovbound(n):
    count = 0
    if n <= 5:
        count = n
    else:
        if n%6 == 0 or n%6 == 3:
            count = 3 + markov_dict[n/3]
        if n%6 == 1:
            count = 4 + markov_dict[(n-1)/3]
        if n%6 == 2 or n%6 == 4:
            count = 2 + markov_dict[n/2]
        if n%6 == 5:
            count = 3 + markov_dict[(n-1)/2]
    markov_dict[n] = count

for i in range (1, 2000001):
    markovbound(i)

def precompute_summands(n):
    c = markov_dict[n]
    # need to make sure it never rounds down                                   
    log_bound = c/float(log(n, 3)) + 1/float(100000000000)                                                           
    bound = float(log_bound)/3 - 1
    return bound

def compute_complexities(num):
    # count how often the new summand bound kicks in
    numImproved = 0
    nMax = num

    cMax = int(ceil(3.*log(nMax)/log(2)))
    print 'cMax = ', cMax
    # initialize the dictionary 
    Compl={}
    for n in range(2,nMax+1):
        Compl[n]=cMax
    Compl[1]=1
    # now Compl[n] is always greater or equal to the true complexity
    for n in range(2,nMax+1):
        # test the sums
        a = Compl[n-1]+1
        if a < Compl[n]:
            Compl[n]=a  # the usual best value
        target = Compl[n-1]
        k=target/2

        while (A000792(k)+A000792(target-k)<n):
            k=k-1
        limitm = A000792(k)
        markov_sumbound = precompute_summands(n)
        up_to = int(ceil(n**markov_sumbound))
        if (up_to < limitm):
            numImproved += 1
        limitm = min(limitm, up_to)
        for m in range(6,limitm+1):
            sumvalue = Compl[m]+Compl[n-m]
            if sumvalue < Compl[n]:
                Compl[n] = sumvalue
        # test for the products
        for k in range(2, min(n,nMax/n)+1):
            prodvalue = Compl[k]+Compl[n]
            if prodvalue <Compl[k*n]:
                Compl[k*n]=prodvalue
    # end of computation of complexities
    print "Computed complexities upto nMax Compl[",nMax,"] = ", Compl[nMax]
    print "Num improved ", numImproved
"""
    # report the first value. For example
first =0
for n in range(1,nMax+1):
    if Compl[n]>first:
        first = Compl[n]
        print 'First value of complexity ', Compl[n], '  taken for n = ', n
"""

compute_complexities(2000000)
