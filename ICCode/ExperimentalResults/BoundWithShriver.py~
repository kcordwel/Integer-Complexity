#from __future__ import division
import sys
sys.path.insert(0,'/Volumes/RIEMANN/Todo/Matematicas/Python')
from A000792 import *
from fractions import Fraction
from math import ceil
from math import log
from math import floor
from math import *

#print [A000792(n) for n in range(1,21)]
markov_dict = {}

# print "started"

def markovbound(n):
    count = 0
    if n <= 5:
        count = n
    else:
        if n%6 == 0 or n%6 == 3:
            count = 3 + markov_dict[n/3]
        if n%6 == 1:
            count = 4 + markov_dict[(n-1)/3]
        if n%6 == 2 or n%6 == 4:
            count = 2 + markov_dict[n/2]
        if n%6 == 5:
            count = 3 + markov_dict[(n-1)/2]
    markov_dict[n] = count

for i in range (1, 2000001):
    markovbound(i)
#    print markov_dict[i]

def shriver_markov_bound():
    #count = 0
    file = open('moreannealingresults.txt', 'r')
    for line in file:
        # lines are of the format n f(n) where f(n) comes from Shriver's 
        # greedy alg run in base 2310
        shriver_arr = line.split(' ')
        # don't mess with the small values
        if int(shriver_arr[0]) > 5 and int(shriver_arr[0]) < 2000001:
            # update dict values
            if markov_dict[int(shriver_arr[0])] > int(shriver_arr[1]):
                markov_dict[int(shriver_arr[0])] = int(shriver_arr[1])
    #            count = count + 1
    file.close()
    #print count
shriver_markov_bound()

def precompute_summands(n):
    c = markov_dict[n]
    # need to make sure it never rounds down                                   
    log_bound = c/float(log(n, 3)) + 1/float(100000000000)
    # print log_bound                                                           
    bound = float(log_bound)/3 - 1
    return bound

#print precompute_summands(10000)

# for i in range (2, 30):
#    print int(ceil(i**precompute_summands(i)))

def compute_complexities(num):
    # count how often the new summand bound kicks in
    numImproved = 0
    nMax = num

    cMax = int(ceil(3.*log(nMax)/log(2)))
    print 'cMax = ', cMax
# initialize the dictionary 
    Compl={}
    for n in range(2,nMax+1):
        Compl[n]=cMax
    Compl[1]=1
# now Compl[n] is always greater or equal to the true complexity
    for n in range(2,nMax+1):
        # test the sums
        a = Compl[n-1]+1
        if a < Compl[n]:
            Compl[n]=a  # the usual best value
    #print [Compl[i] for i in range(1,13)]
        target = Compl[n-1]
    #print 'target = ', target
        k=target/2
    #print 'k = ', k
        while (A000792(k)+A000792(target-k)<n):
            k=k-1
        limitm = A000792(k)
        markov_sumbound = precompute_summands(n)
        #markov_fracexp = Fraction(markov_sumbound)
        up_to = int(ceil(n**markov_sumbound))
#        print "n is"
        #print n
#        print "markov bound"
        #print markov_dict[n]
#        print "original bound "
#        print limitm
#        print "new bound "
#        print up_to
        if (up_to < limitm):
            numImproved += 1
        limitm = min(limitm, up_to)
    #print 'For n = ',n, '  we find limitm = ', limitm, ' and k = ',k
        for m in range(6,limitm+1):
            sumvalue = Compl[m]+Compl[n-m]
            if sumvalue < Compl[n]:
                Compl[n] = sumvalue
            #print 'counterexample found for n = ', n
    # test for the products
        for k in range(2, min(n,nMax/n)+1):
            prodvalue = Compl[k]+Compl[n]
            if prodvalue <Compl[k*n]:
                Compl[k*n]=prodvalue
    # end of computation of complexities
    print "Computed complexities upto nMax Compl[",nMax,"] = ", Compl[nMax]
    print "Num improved ", numImproved
"""
    # report the first value. For example
first =0
for n in range(1,nMax+1):
    if Compl[n]>first:
        first = Compl[n]
        print 'First value of complexity ', Compl[n], '  taken for n = ', n
"""

compute_complexities(2000000)
